@model PLANMHE.Models.Plan
@{
	ViewData["Title"] = "Lịch Sử Kế Hoạch";
	ViewData["CurrentPage"] = "/HistoryPlan/Detail";
}

<div class="main-box">
	<div class="header-section">
		<div class="left-icon"><i class="ace-icon fa fa-star orange"></i></div>
		<div class="page-title">Lịch Sử Kế Hoạch Sản Xuất</div>
		<div class="right-settings"><i class="fa fa-regular fa-gear"></i></div>
	</div>
</div>

<div class="outer-wrapper">
	<div class="tabs">
		<button class="active">Lịch sử kế hoạch</button>
	</div>
	<div class="tab-pane" style="padding:0px;">
		<div id="tableContainer" class="table-container">
			<table id="excelTable" class="table excel-table" style="display: none;">
				<tbody></tbody>
			</table>
		</div>
	</div>
</div>

<!-- NÚT XUẤT EXCEL (GỌI SERVER EPPLUS) -->
<div class="foter-category" style="position: fixed; bottom: 0; left: 0; width: 100%; background-color: #f8f9fa; padding: 16px; box-shadow: 0 -2px 5px rgba(0,0,0,0.1); text-align: right; z-index: 1000;">
	<button type="button" id="btnExportExcelServer" class="import"
			style="background-color:white; border:1px solid #a7c9a1; font-family: 'Times New Roman', sans-serif; padding:8px 16px; color:#a7c9a1; cursor:pointer; border-radius:4px; margin-right:8px;">
		<i class="fa-solid fa-file-excel" style="padding-right: 5px;"></i>Xuất Excel
	</button>
</div>

<script>
	$(document).ready(function () {
		let tableData = @Html.Raw(ViewBag.TableData ?? "[]");
		let colWidths = @Html.Raw(ViewBag.ColWidths ?? "[]");
		let rowHeights = @Html.Raw(ViewBag.RowHeights ?? "[]");
		let formats = @Html.Raw(ViewBag.Formats ?? "[]");
		let mergedCells = @Html.Raw(ViewBag.MergedCells ?? "[]");
		let totalColumnIndex = @ViewBag.TotalColumnIndex;
		let validColumnIndices = [...new Set(@Html.Raw(ViewBag.ValidColumnIndices ?? "[]"))];
		let lockedCells = @Html.Raw(ViewBag.LockedCells ?? "[]");

		if (tableData.length > 0) {
			renderTable(tableData, formats, mergedCells, rowHeights, colWidths, totalColumnIndex, validColumnIndices, lockedCells);
		}

		// === GIỮ NGUYÊN HÀM XUẤT EXCEL CŨ (XLSX JS) ===
		window.exportToExcel = function () {
			if (!tableData || tableData.length === 0) {
				alert("Không có dữ liệu để xuất!");
				return;
			}
			const wb = XLSX.utils.book_new();
			const ws = XLSX.utils.json_to_sheet(tableData, { skipHeader: true });

			ws['!merges'] = mergedCells.map(merge => ({
				s: { r: merge.startRow - 1, c: merge.startCol - 1 },
				e: { r: merge.startRow - 1 + (merge.rowSpan - 1), c: merge.startCol - 1 + (merge.colSpan - 1) }
			}));

			ws['!cols'] = colWidths.map(width => ({ wpx: Math.max(Math.round(width || 60), 60) }));
			ws['!rows'] = rowHeights.map(height => ({ hpx: Math.max(Math.round(height || 30), 30) }));

			tableData.forEach((row, rowIndex) => {
				row.forEach((cellData, colIndex) => {
					const cellAddress = XLSX.utils.encode_cell({ r: rowIndex, c: colIndex });
					const cellFormat = formats[rowIndex][`col${colIndex + 1}`] || '';

					let bgColor = '#ffffff';
					let fgColor = '#000000';
					let fontSize = 14;
					let fontWeight = 'normal';
					let textAlign = colIndex === totalColumnIndex ? 'center' : 'left';
					let fontName = 'Segoe UI';

					cellFormat.split(';').forEach(style => {
						const [key, value] = style.split(':').map(s => s.trim());
						if (key === 'background-color') bgColor = value.replace('#', '');
						if (key === 'color') fgColor = value.replace('#', '');
						if (key === 'font-size') fontSize = parseFloat(value) || 14;
						if (key === 'font-weight') fontWeight = value;
						if (key === 'text-align') textAlign = value;
						if (key === 'font-family') fontName = value;
					});

					ws[cellAddress] = ws[cellAddress] || { v: cellData || '' };
					ws[cellAddress].s = {
						fill: { fgColor: { rgb: bgColor } },
						font: {
							name: fontName,
							sz: fontSize * 0.75,
							bold: fontWeight === 'bold' || parseInt(fontWeight) > 600,
							color: { rgb: fgColor }
						},
						alignment: { horizontal: textAlign, vertical: 'center' }
					};
				});
			});

			XLSX.utils.book_append_sheet(wb, ws, "Plan");
			const planId = @Model.Id;
			XLSX.writeFile(wb, `Plan_${planId}_${new Date().toISOString().slice(0, 10)}.xlsx`);
		};

		// === THÊM MỚI: XUẤT EXCEL BẰNG EPPLUS (SERVER) ===
		document.getElementById('btnExportExcelServer').addEventListener('click', function () {
			const planId = @Model.Id;
			if (!planId) return alert('Không có ID kế hoạch!');

			const btn = this;
			const originalHTML = btn.innerHTML;
			btn.disabled = true;
			btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Đang xuất...';

			fetch(`/HistoryPlan/ExportToExcel?planId=${planId}`, {
				method: 'GET',
				headers: {
					'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]')?.value || ''
				}
			})
			.then(response => {
				if (!response.ok) throw new Error('Lỗi server: ' + response.status);
				const disposition = response.headers.get('content-disposition');
				const filename = disposition?.match(/filename="?(.+)"?/)?.[1] || `KeHoach_${planId}.xlsx`;
				return response.blob().then(blob => ({ blob, filename }));
			})
			.then(({ blob, filename }) => {
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = filename;
				document.body.appendChild(a);
				a.click();
				a.remove();
				URL.revokeObjectURL(url);

				btn.disabled = false;
				btn.innerHTML = originalHTML;
			})
			.catch(err => {
				console.error('Export error:', err);
				alert('Xuất file thất bại: ' + err.message);
				btn.disabled = false;
				btn.innerHTML = originalHTML;
			});
		});

		// === GIỮ NGUYÊN HÀM RENDER TABLE ===
		function renderTable(data, formats, mergedCells, rowHeights, colWidths, totalColumnIndex, validColumnIndices, lockedCells) {
			const $table = $('#excelTable');
			const $tbody = $table.find('tbody').empty();
			const pixelColWidths = colWidths.map(width => Math.max(Math.round(width || 60), 60));
			const pixelRowHeights = rowHeights.map(height => Math.max(Math.round(height || 30), 30));
			const skipCells = {};
			const fragment = document.createDocumentFragment();

			data.forEach((rowData, rowIndex) => {
				const rowHeightPx = pixelRowHeights[rowIndex] || 30;
				const $tr = $('<tr>').css({
					'height': rowHeightPx + 'px',
					'min-height': rowHeightPx + 'px',
					'max-height': rowHeightPx + 'px'
				});

				rowData.forEach((cellData, colIndex) => {
					const cellKey = `${rowIndex}-${colIndex}`;
					if (skipCells[cellKey]) return;

					const $td = $('<td>').text(cellData || '').css({
						'width': pixelColWidths[colIndex] + 'px',
						'min-width': pixelColWidths[colIndex] + 'px',
						'max-width': pixelColWidths[colIndex] + 'px',
						'height': rowHeightPx + 'px',
						'min-height': rowHeightPx + 'px',
						'max-height': rowHeightPx + 'px',
						'box-sizing': 'border-box',
						'overflow': 'visible'
					});

					let css = formats[rowIndex][`col${colIndex + 1}`] ||
						`background-color: #${colIndex === totalColumnIndex ? 'f0f0f0' : 'ffffff'}; color: #000000; font-size: 14px; font-weight: normal; text-align: ${colIndex === totalColumnIndex ? 'center' : 'left'}; font-family: Segoe UI`;

					let isMerged = false;
					let hasRowSpan = false;
					mergedCells.forEach(merge => {
						if (merge.startRow === rowIndex + 1 && merge.startCol === colIndex + 1) {
							isMerged = true;
							if (merge.rowSpan > 1) hasRowSpan = true;
						}
					});

					if (isMerged) {
						css = css.replace(/text-align:\s*[^;]+;/, 'text-align: center;');
						if (!css.includes('text-align')) css += ';text-align: center';
						if (hasRowSpan) {
							css = css.replace(/vertical-align:\s*[^;]+;/, 'vertical-align: middle;');
							if (!css.includes('vertical-align')) css += ';vertical-align: middle';
						}
					}

					if (colIndex === totalColumnIndex) {
						css += ';background-color: #f0f0f0;cursor: not-allowed;';
						$td.addClass('disabled-cell');
					}

					const isLocked = lockedCells.some(cell => cell.row === rowIndex + 1 && cell.col === colIndex + 1);
					if (isLocked) {
						css += ';cursor: not-allowed;';
						$td.addClass('disabled-cell');
					}

					$td.attr('style', css);
					$td.data('row', rowIndex).data('col', colIndex);

					mergedCells.forEach(merge => {
						if (merge.startRow === rowIndex + 1 && merge.startCol === colIndex + 1) {
							if (merge.rowSpan > 1) $td.attr('rowspan', merge.rowSpan);
							if (merge.colSpan > 1) $td.attr('colspan', merge.colSpan);

							let mergedWidth = 0;
							for (let c = 0; c < merge.colSpan; c++) {
								mergedWidth += pixelColWidths[colIndex + c] || 60;
							}
							$td.css({
								'width': Math.round(mergedWidth) + 'px',
								'min-width': Math.round(mergedWidth) + 'px',
								'max-width': Math.round(mergedWidth) + 'px',
								'height': (rowHeightPx * merge.rowSpan) + 'px',
								'min-height': (rowHeightPx * merge.rowSpan) + 'px',
								'max-height': (rowHeightPx * merge.rowSpan) + 'px'
							});

							for (let r = 0; r < merge.rowSpan; r++) {
								for (let c = 0; c < merge.colSpan; c++) {
									if (r === 0 && c === 0) continue;
									skipCells[`${rowIndex + r}-${colIndex + c}`] = true;
								}
							}
						}
					});

					$tr.append($td);
				});
				fragment.appendChild($tr[0]);
			});

			$tbody.append(fragment);
			$table.css({
				'table-layout': 'fixed',
				'width': 'auto',
				'border-collapse': 'collapse'
			}).show();
		}
	});
</script>
